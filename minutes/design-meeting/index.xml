<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design meeting on Rust Lang - Compiler Team</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/</link><description>Recent content in Design meeting on Rust Lang - Compiler Team</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://rust-lang.github.io/compiler-team/minutes/design-meeting/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-01-streaming-dep-graph-proposal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-01-streaming-dep-graph-proposal/</guid><description>&amp;ldquo;Streaming dep graph&amp;rdquo; proposal Summary of the proposal Currently, incremental compilation begins by loading the old dependency graph and then &amp;ndash; as execution proceeds &amp;ndash; building a new dependency graph in memory. At the end of compilation, this new graph is written out.
PR #60035 proposes to change how the new graph is handled. Instead of building the graph in memory and writing it out at the end, we &amp;ldquo;stream&amp;rdquo; out a series of changes to the dep-graph as we go.</description></item><item><title>Dep-graph loading (#62083)</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-11-DepGraph-persistence-PR62038/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-11-DepGraph-persistence-PR62038/</guid><description>design meeting 2019-10-11 Zulip stream
introduction Dear @T-compiler/meeting,
Today we will be having a design meeting. The topic was originally sketched as &amp;ldquo;some Zoxc PR&amp;rdquo;. We&amp;rsquo;ve since narrowed that down to discuss #62038, which is a refactoring to how dep-graph loading occurs. @Zoxc wrote up a comment giving a summary of the ideas. Note that this PR itself is an incremental step towards #60035, which aims to make dep-graph loading/saving more continuous.</description></item><item><title>Place Interning</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-27-place-interning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-27-place-interning/</guid><description>Place projection interning meeting 2019-09-27 Zulip stream
Ideas to pursue at some later point or in parallel removing the field from the projections get rid of static from PlaceBase I (oli-obk) think this would be good to pursue ealier than later since it&amp;rsquo;ll just eliminate an annoying piece that we don&amp;rsquo;t really care about most of the time intern entire places at the MIR level interning (base, Vec&amp;lt;projection&amp;gt;) means less re-use overall though nice hack: rfirst 128 (eddyb suggests 2^16) locals or so can be mapped to themselves could even be extended for whatever the most common projections are if that proves useful insert gratuitous reference to random compression methods here Ideas rejected intern the Vec&amp;lt;Projection&amp;gt; to a &amp;amp;[Projection] Rejected: List is better because it is smaller, and we can use a PlaceRef for cases where you want to do subslicing Although &amp;amp;[Projection] would mean that a.</description></item><item><title>Planning the gcx, tcx transition</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-06-21-the-gcx-tcx-transition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-06-21-the-gcx-tcx-transition/</guid><description>Planning the &#39;gcx, &#39;tcx transition Zulip thread Summary Discuss the end-state for tcx Plan the steps we will take to get there and time frame Motivation Now that we have removed the per-inference context interners, we plan to transition the compiler to a different naming scheme. This is a major shift and something we should plan carefully.
Also, it&amp;rsquo;s an opportunity to consider an alternate naming scheme &amp;ndash; tcx and &#39;tcx is not known to be particularly popular.</description></item><item><title>Roadmap 2020</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-04-Roadmap-2020-Goals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-04-Roadmap-2020-Goals/</guid><description>Roadmap 2020 Compiler Discussion Zulip topic
2019 roadmap (for reference) The compiler team has five main themes of work for this year:
Improving &amp;ldquo;core strength&amp;rdquo; by lowering raw compilation times and also generating better code (which in turn can help with compilation times) Improved IDE integration, including support for typed completions Extracting parts of rustc into libraries, which are easier to understand and maintain but also help in developing a Rust specification Supporting lang team in key feature development, such as around async fn support, or improvements to the trait system Improving our documentation and organization, helping to make it clearer what is going on at any given time, and how people can get involved.</description></item><item><title>Target Tier Policy</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-20-target-tier-policy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-20-target-tier-policy/</guid><description>Target Tier Policy Zulip thread Proposal issue: rust-lang/rust#166 Original proposal with history Summary We should have an official, objective policy for adding new (tier 3) targets, and for raising targets to tier 2 (with rustup builds) or even tier 1.
Conclusion: Josh to revise policy based on feedback (done, see below) and subsequently submit as an RFC.
Motivation Rust developers regularly implement new targets in the Rust compiler, and reviewers of pull requests for such new targets would like a clear, consistent policy to cite for accepting or rejecting such targets.</description></item><item><title>Triage Working Group Discussion</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-07-08-triage-wg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-07-08-triage-wg/</guid><description>Triage Working Group Discussion Zulip thread Summary Discussed ideas of a triage working group and how that might interact Discussed pnkfelix/nikomatsakis taking leave over next few weeks and what to do in the meantime Discussed the problems around review queues pnkfelix/nikomatsakis absence pnkfelix will be going on parental leave for 2 months starting July 15. nikomatsakis will be on PTO for a month or so, with limited availability.</description></item><item><title>Unify Dataflow Frameworks (#202)</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-09-unified-dataflow-framework/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-09-unified-dataflow-framework/</guid><description>Design Meeting 2019-11-08 Zulip Stream
Agenda Design doc: https://hackmd.io/@39Qr_z9cQhasi25sGjmFnA/Skvd9rztS
Explain the current state of things
We currently have two wholly separate APIs for dataflow, one for bit-vector problems and one that allows arbitrary transfer functions but still restricts the lattice to a powerset of indices. I want to merge these two to make code more DRY. The prototype implementation is described pretty thoroughly in the design doc, but maybe go over it a bit?</description></item><item><title>Working Group Retrospective</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-16-Working-Group-Retrospective/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-16-Working-Group-Retrospective/</guid><description>Working Group Retrospective Zulip stream or read on the Zulip archive What you are looking at We did a short survey before the meeting. The following notes were scraped from the 10 responses. I tried to de-duplicate common items. Towards the end, you will find some minutes that were taken during the meeting itself. &amp;ndash;nikomatsakis
Things to KEEP doing Working groups are useful Nice to know who to talk to in order to get involved this was more of a struggle before Providing opportunities for mentorship is good Scoping out small groups of decision makers for &amp;ldquo;in the weeds&amp;rdquo; decisions Weekly updates Dedicated Zulip streams: great to have ability to link/skim, even if most are muted Regular meetings are a good way to keep working groups focused Things to STOP doing Maybe fewer working groups, with more time/energy invested in each?</description></item><item><title>rust-analyzer and libraryification</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-13-rust-analyzer-and-libraryification/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-13-rust-analyzer-and-libraryification/</guid><description>rust-analyzer and libraryification Zulip thread Proposal issue: rust-lang/rust#160 Additional notes: hackmd document Summary Goal of the meeting is to update on rust-analyzer plans and discuss taking the next step towards extracting &amp;ldquo;standalone libraries&amp;rdquo; that can be shared between rustc and rust-analyzer.
Update on rust-analyzer Rust-analyzer has made big strides and now includes
name resolution a partial type checker preliminary integration with chalk for trait solving as well as a shared lexer with rustc What does library-ification mean?</description></item></channel></rss>